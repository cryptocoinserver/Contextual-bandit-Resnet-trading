# -*- coding: utf-8 -*-
"""latex_table_resnet_ESWA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aZ4BlJO4rML-uOFpmyT1_xRsQEZJXdY4
"""

# from google.colab import drive
# drive.mount('/content/drive')

#!pip install empyrical
#!pip install ta

# -*- coding: utf-8 -*-
"""
Created on Sat May 16 19:48:40 2020

@author: leona

"""

#path_input = r'/content/drive/MyDrive/USP/Doutorado/Artigo RRL-DeepLearning/Results/results - tables;crypto;extended datas/'
path_input = r'/content/drive/MyDrive/USP/Doutorado/Artigo RRL-DeepLearning/Results/results - tables;crypto;extended datastc0.0001/'
path_data = r'/content/drive/MyDrive/USP/Doutorado/Artigo RRL-DeepLearning/Git/Contextual-bandit-Resnet-trading/run'
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import math
from scipy.stats import wilcoxon
from BitcoinTradingEnv import BitcoinTradingEnv as btenv

def moving_average(data_set, periods=3):
    weights = np.ones(periods) / periods
    return np.convolve(data_set, weights, mode='valid')

def calculate_AR(series,init_value):  
    if math.isnan(((((np.sum(series)+init_value)/init_value+1)**(1/len(series))))**365-1):
      return 0
    else:
      return ((((np.sum(series)+init_value)/init_value+1)**(1/len(series))))**365-1
    #return ((((np.sum(series)+init_value)/init_value+1)**(1/len(series))))**365-1
    
def calculate_SR(series,init_value):
    risk_free = 0.0001
    if math.isnan((((((np.sum(series)+init_value)/init_value+1)**(1/len(series))))-1-risk_free)/np.std(series)*np.sqrt(365)):
      return 0
    else:
      return (((((np.sum(series)+init_value)/init_value+1)**(1/len(series))))-1-risk_free)/np.std(series)*np.sqrt(365)
    #return (((((np.sum(series)+init_value)/init_value+1)**(1/len(series))))-1-risk_free)/np.std(series)*np.sqrt(365)

############################################################
# Load first datas
############################################################
assets = ['btc','dash','eth','ltc','nxt','xmr']

######################################################################################################################
# Create table for cumlateive returns
######################################################################################################################
df = pd.DataFrame(columns = [' ','Asset','BH','RRL','DQL','A2C','BSTS','RSLSTM-A'])
#df['Asset']= assets
#df = df.set_index('Asset')

alpha = 0.05
k_fold = 15
min_df_size = 3000
comission = 0.00
gamma = 0.99
M  = 51
mu = 1
n_epoch = 600
decay = 200
reward_strategy = 'return'


input_datas = []

input_datas.append(path_data+'/data/Poloniex_BTCUSD_1h.csv')
input_datas.append(path_data+'/data/Poloniex_DASHUSD_1h.csv')
input_datas.append(path_data+'/data/Poloniex_ETHUSD_1h.csv')
input_datas.append(path_data+'/data/Poloniex_LTCUSD_1h.csv')
input_datas.append(path_data+'/data/Poloniex_NXTBTC_1h.csv')
input_datas.append(path_data+'/data/Poloniex_XMRUSD_1h.csv')


for asset_name, data_name in zip(assets, input_datas):
    data = pd.read_csv(data_name)
    valid_len = int(len(data) * 0.1/2)
    test_len = valid_len
    train_len = int(len(data)) - valid_len*2   
    test_df = data[train_len+M+valid_len:]
    length = len(test_df)
    test_env = btenv(test_df, initial_balance=10000, commission=comission,
                     reward_func=reward_strategy, M = M , mu = mu,length = length,
                     scaling = False)
    if asset_name == 'nxt':
      firs_value_test = test_env.df['Close'][0]*10000
    else:
      firs_value_test = test_env.df['Close'][0]
    a2c = np.sum(np.cumsum(np.load(path_input+'A2C_agent_returns__'+asset_name+'.npy')))
    dql = np.sum(np.cumsum(np.load(path_input+'DQN_agent_returns___'+asset_name+'.npy')))
    rrl = np.sum(np.cumsum(np.load(path_input+'RRL_model_returns_f__'+asset_name+'.npy')))
    bts = np.sum(np.cumsum(np.load(path_input+'cbadapt_agent_returns__'+asset_name+'.npy')))
    resnet = np.sum(np.cumsum(np.load(path_input+'resnet_agent_returns__'+asset_name+'.npy')))
    bh = np.sum(np.cumsum(np.load(path_input+'bh___'+asset_name+'.npy')))
    if asset_name == 'eth':
      df_temp = pd.DataFrame({' ':'ACR','Asset':asset_name,'BH':bh,'RRL':rrl,'DQL':dql,'A2C':a2c,'BSTS':bts,'RSLSTM-A':resnet}, index=[0])
    else:
      df_temp = pd.DataFrame({' ':' ','Asset':asset_name,'BH':bh,'RRL':rrl,'DQL':dql,'A2C':a2c,'BSTS':bts,'RSLSTM-A':resnet}, index=[0])
    df = df.append(df_temp)

for asset_name, data_name in zip(assets, input_datas):
    data = pd.read_csv(data_name)
    valid_len = int(len(data) * 0.1/2)
    test_len = valid_len
    train_len = int(len(data)) - valid_len*2   
    test_df = data[train_len+M+valid_len:]
    length = len(test_df)
    test_env = btenv(test_df, initial_balance=10000, commission=comission,
                     reward_func=reward_strategy, M = M , mu = mu,length = length,
                     scaling = False)
    if asset_name == 'nxt':
      firs_value_test = test_env.df['Close'][0]*10000
    else:
      firs_value_test = test_env.df['Close'][0]
    a2c = calculate_SR(np.load(path_input+'A2C_agent_returns__'+asset_name+'.npy'),firs_value_test)
    dql = calculate_SR(np.load(path_input+'DQN_agent_returns___'+asset_name+'.npy'),firs_value_test)
    rrl = calculate_SR(np.load(path_input+'RRL_model_returns_f__'+asset_name+'.npy'),firs_value_test)
    bts = calculate_SR(np.load(path_input+'cbadapt_agent_returns__'+asset_name+'.npy'),firs_value_test)
    resnet = calculate_SR(np.load(path_input+'resnet_agent_returns__'+asset_name+'.npy'),firs_value_test)
    bh = calculate_SR(np.load(path_input+'bh___'+asset_name+'.npy'),firs_value_test)
    if asset_name == 'eth':
      df_temp = pd.DataFrame({' ':'SR','Asset':asset_name,'BH':bh,'RRL':rrl,'DQL':dql,'A2C':a2c,'BSTS':bts,'RSLSTM-A':resnet}, index=[0])
    else:
      df_temp = pd.DataFrame({' ':' ','Asset':asset_name,'BH':bh,'RRL':rrl,'DQL':dql,'A2C':a2c,'BSTS':bts,'RSLSTM-A':resnet}, index=[0])
    df = df.append(df_temp)

for asset_name, data_name in zip(assets, input_datas):
    data = pd.read_csv(data_name)
    valid_len = int(len(data) * 0.1/2)
    test_len = valid_len
    train_len = int(len(data)) - valid_len*2   
    test_df = data[train_len+M+valid_len:]
    length = len(test_df)
    test_env = btenv(test_df, initial_balance=10000, commission=comission,
                     reward_func=reward_strategy, M = M , mu = mu,length = length,
                     scaling = False)
    if asset_name == 'nxt':
      firs_value_test = test_env.df['Close'][0]*10000
    else:
      firs_value_test = test_env.df['Close'][0]
    a2c = calculate_AR(np.load(path_input+'A2C_agent_returns__'+asset_name+'.npy'),firs_value_test)
    dql = calculate_AR(np.load(path_input+'DQN_agent_returns___'+asset_name+'.npy'),firs_value_test)
    rrl = calculate_AR(np.load(path_input+'RRL_model_returns_f__'+asset_name+'.npy'),firs_value_test)
    bts = calculate_AR(np.load(path_input+'cbadapt_agent_returns__'+asset_name+'.npy'),firs_value_test)
    resnet = calculate_AR(np.load(path_input+'resnet_agent_returns__'+asset_name+'.npy'),firs_value_test)    
    bh = calculate_AR(np.load(path_input+'bh___'+asset_name+'.npy'),firs_value_test)
    if asset_name == 'eth':
      df_temp = pd.DataFrame({' ':'AR','Asset':asset_name,'BH':bh,'RRL':rrl,'DQL':dql,'A2C':a2c,'BSTS':bts,'RSLSTM-A':resnet}, index=[0])
    else:
      df_temp = pd.DataFrame({' ':' ','Asset':asset_name,'BH':bh,'RRL':rrl,'DQL':dql,'A2C':a2c,'BSTS':bts,'RSLSTM-A':resnet}, index=[0])
    df = df.append(df_temp)

df

df['BH'] = df['BH'].map('{:.2e}'.format)
df['RRL'] = df['RRL'].map('{:.2e}'.format)
df['DQL'] = df['DQL'].map('{:.2e}'.format)
df['A2C'] = df['A2C'].map('{:.2e}'.format)
df['BSTS'] = df['BSTS'].map('{:.2e}'.format)
df['RSLSTM-A'] = df['RSLSTM-A'].map('{:.2e}'.format)

caption = 'Consolidate results for the the accumulated returns, annualized return and sharpe ration for all the employed models and assets using transaction cost equals to 0.001'
print(df.to_latex(index=False,label = 'tab:final_resultstc0',caption=caption,escape = False))

